# Copyright (C) WD Studios Corp. All Rights Reserved.
if ! $(__QT_RULES_INCLUDED) {
  __QT_RULES_INCLUDED = 1 ;

  QtDefaultModules ?= Core Gui ;

  rule _QtNormalizePath path
  {
    return $(path) ;
  }

  rule _QtEnsureUnique list
  {
    local result = ;
    for item in $(list) {
      if ! $(item) { continue ; }
      if ! $(item) in $(result) {
        result += $(item) ;
      }
    }
    return $(result) ;
  }

  rule _QtNormalizeModules modules
  {
    local normalized = ;
    for module in $(QtDefaultModules) $(modules) {
      if ! $(module) { continue ; }
      local trimmed = [ MATCH "^Qt(.+)" : $(module) ] ;
      if $(trimmed) {
        module = $(trimmed[1]) ;
      }
      normalized += $(module) ;
    }
    return [ _QtEnsureUnique $(normalized) ] ;
  }

  rule _QtResolveDir
  {
    if $(_QT_DIR) { return $(_QT_DIR) ; }

    local candidates =
      $(QtDir)
      $(QtSdkDir)
      $(QtInstallDir)
      $(QtRoot)
      $(Qt5Dir)
      $(Qt5Root)
      $(QT_DIR)
      $(QT5_DIR)
      $(_DEVTOOL)/qt
      $(_DEVTOOL)/qt5
      $(_DEVTOOL)/Qt
    ;
    for candidate in $(candidates) {
      if ! $(candidate) { continue ; }
      if [ GLOB $(candidate)/include : * ] {
        _QT_DIR = [ _QtNormalizePath $(candidate) ] ;
        break ;
      }
    }

    if ! $(_QT_DIR) {
      Exit Qt toolkit path not configured. Set 'QtDir' jam variable or 'QT_DIR' environment variable to the Qt kit directory (contains bin/, include/, lib/). ;
    }

    return $(_QT_DIR) ;
  }

  rule _QtEnsureTooling
  {
    local qt_dir = [ _QtNormalizePath [ _QtResolveDir ] ] ;
    _QT_INCLUDE_DIR ?= [ _QtNormalizePath $(qt_dir)/include ] ;
    _QT_LIB_DIR ?= [ _QtNormalizePath $(qt_dir)/lib ] ;
    _QT_BIN_DIR ?= [ _QtNormalizePath $(qt_dir)/bin ] ;

    local exe_ext = ;
    if $(OS) = NT { exe_ext = .exe ; }

    _QT_MOC ?= $(QtMoc) ;
    _QT_MOC ?= $(_QT_BIN_DIR)/moc$(exe_ext) ;

    _QT_UIC ?= $(QtUic) ;
    _QT_UIC ?= $(_QT_BIN_DIR)/uic$(exe_ext) ;

    _QT_RCC ?= $(QtRcc) ;
    _QT_RCC ?= $(_QT_BIN_DIR)/rcc$(exe_ext) ;
  }

  rule _QtSelectLibrary candidates
  {
    for candidate in $(candidates) {
      if [ GLOB $(_QT_LIB_DIR) : $(candidate) ] { return $(candidate) ; }
    }
    return $(candidates[1]) ;
  }

  rule _QtLibraryFile module
  {
    local major = $(QtMajorVersion) ;
    local major_match = [ MATCH "^([0-9]+)" : $(major) ] ;
    if $(major_match[1]) { major = $(major_match[1]) ; }
    major ?= 5 ;

    local debug_suffix = ;
    if $(Config) = dbg { debug_suffix = d ; }

    # Windows library naming
    if $(OS) = NT {
      if $(major) = 4 {
        if $(module:U) = MAIN {
          local qt4_candidates =
            qtmain$(debug_suffix).lib
            qtmain.lib
          ;
          return [ _QtSelectLibrary $(qt4_candidates) ] ;
        }

        local qt4_release = Qt$(module)4.lib ;
        local qt4_debug = Qt$(module)d4.lib ;
        if $(Config) = dbg { return [ _QtSelectLibrary $(qt4_debug) $(qt4_release) ] ; }
        return [ _QtSelectLibrary $(qt4_release) $(qt4_debug) ] ;
      }

      if $(module:U) = MAIN {
        local entry_candidates =
          Qt$(major)Main$(debug_suffix).lib
          Qt$(major)Main.lib
        ;

        if $(major) >= 6 {
          entry_candidates +=
            Qt$(major)EntryPoint$(debug_suffix).lib
            Qt$(major)EntryPoint.lib
          ;
        }

        entry_candidates +=
          qtmain$(debug_suffix).lib
          qtmain.lib
        ;

        return [ _QtSelectLibrary $(entry_candidates) ] ;
      }

      local qt_release = Qt$(major)$(module).lib ;
      local qt_debug = Qt$(major)$(module)d.lib ;
      if $(Config) = dbg { return [ _QtSelectLibrary $(qt_debug) $(qt_release) ] ; }
      return [ _QtSelectLibrary $(qt_release) $(qt_debug) ] ;
    }

    # macOS framework naming
    if $(OS) = MACOSX {
      if $(module:U) = MAIN { return ; } # No main lib needed on macOS

      # Qt frameworks on macOS
      local framework = Qt$(major)$(module) ;
      return -framework $(framework) ;
    }

    # Linux shared library naming
    if $(module:U) = MAIN { return ; } # No main lib needed on Linux

    local lib_name = Qt$(major)$(module) ;
    if $(Config) = dbg {
      # Try debug version first, fallback to release
      local debug_candidates =
        libQt$(major)$(module)$(debug_suffix).so
        libQt$(major)$(module).so
      ;
      return [ _QtSelectLibrary $(debug_candidates) ] ;
    }
    return libQt$(major)$(module).so ;
  }

  rule AddQtRuntimeDeploy modules
  {
    if $(TargetType) != exe { return ; }
    if $(CheckOnly) = yes { return ; }

    _QtEnsureTooling ;

    # Only Windows needs runtime deployment
    if $(OS) != NT { return ; }

    local windeploy = [ MakePathAbsolute $(JAM_CWD) : $(_QT_BIN_DIR)/windeployqt.exe ] ;

    local deploy_mode = --release ;
    if $(Config) = dbg { deploy_mode = --debug ; }

    for qt_target in $(Target) {
      local out_dir = $($(qt_target)__OutDir) ;
      if ! $(out_dir) { continue ; }
      local exe_path = $(out_dir)/$(qt_target) ;
      $(qt_target)__POSTLINK_CMD =
        $($(qt_target)__POSTLINK_CMD)
        if not exist "$(windeploy)" goto qtdeploy_missing
        call "$(windeploy)" $(deploy_mode) --dir "$(out_dir)" "$(exe_path)"
        goto qtdeploy_done
        :qtdeploy_missing
        echo Qt runtime deployment requires 'windeployqt.exe'. Expected at $(windeploy)
        exit /b 13
        :qtdeploy_done
      ;
    }
  }

  rule AddQtCompileOpt modules : target
  {
    _QtEnsureTooling ;

    local resolved_modules = $(modules) ;
    if ! $(resolved_modules) { resolved_modules = $(UseQtLibs) $(DefQtLibs) ; }
    resolved_modules = [ _QtNormalizeModules $(resolved_modules) ] ;

    local include_dirs = $(_QT_INCLUDE_DIR) ;
    local macros = ;
    local moc_includes = -I$(_QT_INCLUDE_DIR) ;

    for module in $(resolved_modules) {
      local inc_dir = [ _QtNormalizePath $(_QT_INCLUDE_DIR)/Qt$(module) ] ;
      include_dirs += $(inc_dir) ;
      macros += -DQT_$(module:U)_LIB ;
      moc_includes += -I$(inc_dir) ;
    }

    include_dirs = [ _QtEnsureUnique $(include_dirs) ] ;
    macros = [ _QtEnsureUnique $(macros) ] ;

    AddIncludes += $(include_dirs) ;
    CPPopt += $(macros) ;

    local moc_opt = $(moc_includes) $(macros) $(dll_opt) ;
    $(target)__MOC_OPT = $(moc_opt) ;
  }

  rule AddQtLinkOpt modules
  {
    if ! $(TargetType) in exe dll { return ; }

    _QtEnsureTooling ;

    local resolved_modules = $(modules) ;
    if ! $(resolved_modules) { resolved_modules = $(UseQtLibs) $(DefQtLibs) ; }
    resolved_modules = [ _QtNormalizeModules $(resolved_modules) ] ;

    local libs = ;
    for module in $(resolved_modules) {
      libs += [ _QtLibraryFile $(module) ] ;
    }

    if $(TargetType) = exe {
      local entry_lib = [ _QtLibraryFile Main ] ;
      if $(entry_lib) { libs += $(entry_lib) ; }
      
      # Platform-specific system libraries
      if $(OS) = NT {
        libs += shell32.lib ;
      }
      else if $(OS) = MACOSX {
        # macOS system frameworks needed by Qt
        libs += -framework AppKit -framework Carbon -framework IOKit ;
      }
      else {
        # Linux system libraries
        libs += -lpthread -ldl ;
      }
      
      AddQtRuntimeDeploy $(resolved_modules) ;
    }

    libs = [ _QtEnsureUnique $(libs) ] ;
    
    # Platform-specific library path options
    if $(OS) = NT {
      LINKopt += -libpath:$(_QT_LIB_DIR) ;
    }
    else if $(OS) = MACOSX {
      LINKopt += -F$(_QT_LIB_DIR) ;
      LINKopt += -Wl,-rpath,$(_QT_LIB_DIR) ;
    }
    else {
      LINKopt += -L$(_QT_LIB_DIR) ;
      LINKopt += -Wl,-rpath,$(_QT_LIB_DIR) ;
    }
    
    AddLibs += $(libs) ;
  }

  # rule how to compile QT .ui target
  #   params: ( target_pathname : sources : target )
  rule CompileUI
  {
    local tgt = $($(3)__OutDir)/$(3) ;
    local ui_h = $(Root)/$(1) ;
    LOCATE on $(2) = $(Root) ;
    Depends $(ui_h) : $(2) ;
    Depends $(tgt) : $(ui_h) ;
    compile_qt_ui $(ui_h) : $(2) ;
  }

  # rule how to compile QT .moc target
  #   params: ( target_pathname : sources : target )
  rule CompileMOC
  {
    Depends $(1) : $(Root)/$(2) ;
    MakeDirectory $(1) : $(1:D) ;
    opt  on $(1) = $($(3)__MOC_OPT) ;
    compile_qt_moc $(1) : $(Root)/$(2) ;

    local obj = $(1:S=$(_OBJ_SUFFIX)) ;
    Depends $(obj) : $(1) ;
    MakeDirectory $(obj) : $(obj:D) ;

    cpp_opt   on $(obj) = $($(3)__CPP_OPT) ;
    pre_opt   on $(obj) = $($(3)__PRE_OPT) ;

    compile_cpp $(obj) : $(1) ;
  }

  # rule how to compile QT .qrc target
  #   params: ( target_pathname : sources : target )
  rule CompileQRC
  {
    Depends $(1) : $(Root)/$(2) ;
    MakeDirectory $(1) : $(1:D) ;
    compile_qt_rcc $(1) : $(Root)/$(2) ;

    local obj = $(1:S=$(_OBJ_SUFFIX)) ;
    Depends $(obj) : $(1) ;
    MakeDirectory $(obj) : $(obj:D) ;

    cpp_opt   on $(obj) = $($(3)__CPP_OPT) ;
    pre_opt   on $(obj) = $($(3)__PRE_OPT) ;

    compile_cpp $(obj) : $(1) ;
  }

  if $(OS) = NT {
    actions quietly compile_qt_ui
    {
    #async
      echo QT-uic $(2:D=)
      call $(_QT_UIC) -o $(1) $(2)
      if errorlevel 1 goto failed
      if not exist $(1) goto failed
      goto end
      :failed
      set ERRORLEVEL=13
      :end
    }

    actions quietly compile_qt_moc
    {
    #async
      echo QT-moc $(2:D=)
      call $(_QT_MOC) $(opt) $(_CPP_BASE_INCLUDES) -o $(1) $(2)
      if errorlevel 1 goto failed
      if not exist $(1) goto failed
      goto end
      :failed
      set ERRORLEVEL=13
      :end
    }

    actions quietly compile_qt_rcc
    {
    #async
      echo QT-rcc $(2:D=)
      call $(_QT_RCC) -o $(1) $(2)
      if errorlevel 1 goto failed
      if not exist $(1) goto failed
      goto end
      :failed
      set ERRORLEVEL=13
      :end
    }
  }
  else {
    # Unix-style actions for Linux and macOS
    actions quietly compile_qt_ui
    {
    #async
      echo QT-uic $(2:D=)
      $(_QT_UIC) -o $(1) $(2) || exit 13
      test -f $(1) || exit 13
    }

    actions quietly compile_qt_moc
    {
    #async
      echo QT-moc $(2:D=)
      $(_QT_MOC) $(opt) $(_CPP_BASE_INCLUDES) -o $(1) $(2) || exit 13
      test -f $(1) || exit 13
    }

    actions quietly compile_qt_rcc
    {
    #async
      echo QT-rcc $(2:D=)
      $(_QT_RCC) -o $(1) $(2) || exit 13
      test -f $(1) || exit 13
    }
  }
}
